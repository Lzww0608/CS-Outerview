## 版本一

解决**内存重叠**问题：

```c
#include <stddef.h>
#include <assert.h>

// Implementation of memmove - safely copies n bytes from src to dst
// Handles overlapping memory regions correctly
void* memmove(void* dst, const void* src, size_t n) {
    // Ensure both pointers are valid
    assert(dst != NULL && src != NULL);

    // Cast to unsigned char pointers for byte-level operations
    unsigned char *d = (unsigned char*) dst;
    const unsigned char *s = (unsigned char*) src;

    // If source and destination are the same, or nothing to copy, return early
    if (d == s || n == 0) {
        return d;
    }

    // Check if memory regions overlap and dst is after src
    // In this case, we need to copy backwards to avoid overwriting source data
    if (d > s && d < s + n) {
        // Start from the end and copy backwards
        s = s + n - 1;
        d = d + n - 1;
        while (n > 0) {
            n--;
            *d = *s;  // Copy byte from source to destination
            d--;      // Move destination pointer backwards
            s--;      // Move source pointer backwards
        }
    } else {
        // No overlap or dst is before src, safe to copy forwards
        while (n > 0) {
            n--;
            *d = *s;  // Copy byte from source to destination
            d++;      // Move destination pointer forwards
            s++;      // Move source pointer forwards
        }
    }

    return dst;
}
```



## 版本二

**性能优化 + 内存重叠**

```c
#include <stddef.h>
#include <assert.h>
#include <stdint.h>

typedef uintptr_t word_t;
#define WORD_SIZE sizeof(word_t)

/**
 * Optimized memmove implementation that handles overlapping memory regions
 * and uses word-aligned operations for better performance.
 */
void* memmove(void* dst, const void* src, size_t n) {
    assert(dst != NULL && src != NULL);
    
    // Handle trivial cases: same pointer or zero bytes
    if (dst == src || n == 0) {
        return dst;
    }

    unsigned char *d = (unsigned char*) dst;
    const unsigned char *s = (unsigned char*) src;

    // Check if regions don't overlap or dst is before src
    // In this case we can copy forward (left to right)
    if (d < s || d >= s + n) {
        // For small copies, just do byte-by-byte copy
        if (n < WORD_SIZE * 2) {
            while (n--) {
                *d = *s;
                d++;
                s++;
            }
            return dst;
        }

        // Align destination pointer to word boundary
        // Calculate how many bytes needed to reach word alignment
        size_t head_bytes = (WORD_SIZE - ((word_t)d % WORD_SIZE)) % WORD_SIZE;
        n -= head_bytes;
        while (head_bytes--) {
            *d = *s;
            s++;
            d++;
        }

        // Now both pointers are word-aligned, copy word by word
        word_t *wd = (word_t*)d;
        const word_t *ws = (const word_t*)s;
        size_t num_words = n / WORD_SIZE;
        while (num_words--) {
            *wd++ = *ws++;
        }

        // Copy remaining bytes that don't fill a complete word
        d = (unsigned char*) wd;
        s = (const unsigned char*) ws;
        n %= WORD_SIZE;
        while (n--) {
            *d = *s;
            d++;
            s++;
        }
    } else {
        // Regions overlap and dst is after src
        // Must copy backward (right to left) to avoid corruption
        d = d + n;
        s = s + n;
        
        // For small copies, just do byte-by-byte copy backward
        if (n < WORD_SIZE * 2) {
            while (n--) {
                *--d = *--s;
            }
            return dst;
        }

        // Align destination end pointer to word boundary
        // Calculate how many bytes from the end to reach word alignment
        size_t tail_bytes = ((uintptr_t)d) % WORD_SIZE;
        n -= tail_bytes;
        while (tail_bytes--) {
            *--d = *--s;
        }

        // Now both pointers are word-aligned, copy word by word backward
        word_t *wd = (word_t *)d;
        const word_t *ws = (const word_t *)s;
        size_t num_words = n / WORD_SIZE;
        while (num_words--) {
            *--wd = *--ws;
        }

        // Copy remaining bytes that don't fill a complete word
        d = (unsigned char *)wd;
        s = (const unsigned char *)ws;
        n %= WORD_SIZE;
        while (n--) {
            *--d = *--s;
        }
    }

    return dst;
}
```

