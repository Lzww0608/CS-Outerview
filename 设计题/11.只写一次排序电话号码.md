## 问题

**输入一个文件，文件中全是杭州电话号码，格式：0571-12345678，且号码不会重复出现，目标输出一个新文件，保证号码有序，可用内存12MB，且只能写一次，你会怎么做？**



12MB的内存限制意味着我们不可能将所有号码（即使是100万个号码，每个约14字节，也超过13MB了）一次性读入内存中进行排序（如 `std::sort`）。

“只能写一次”这个限制排除了“外部归并排序”（External Merge Sort）中“先写入多个临时小文件，再合并写入最终文件”的标准做法，*如果*这个“一次”是指对整个磁盘系统的所有写操作。

但更可能的解释是：**对“目标输出文件”只能进行一次顺序写入**，而不能写了又回头改。

然而，这个问题有一个更优的解法，它完美地利用了所有给定的条件。



### 最佳方案：位图排序 (Bitmap Sort)

这个方案的核心是利用**数据本身的特性**来规避内存限制。



#### 1. 分析数据特性

- **格式**：`0571-12345678`。
- **前缀**：`0571-` 是固定不变的，它不参与排序，我们可以在最后输出时再添加。
- **主体**：`12345678` 是一个8位数。
- **范围**：这8位数的范围是从 `00000000` 到 `99999999`。
- **总数**：总共有 `100,000,000`（1亿）个可能的号码。



#### 2. 分析内存限制 (12MB)

我们是否能用12MB的内存来“表示”这1亿个可能性？

我们不需要存储号码本身，我们只需要存储“这个号码是否存在”。这是一个布尔值（是/否），只需要 **1个 bit**。

我们来计算一下存储1亿个bit需要多少内存：

- 总bit数：100,000,000 bits
- 转换为Bytes：100,000,000 / 8 bits/byte = 12,500,000 bytes
- 转换为MB：12,500,000 / (1024 * 1024)  **11.92 MB**

**结论：** 11.92 MB 恰好在 12MB 的可用内存限制之内。



#### 3. 实施步骤

我们将使用这 11.92 MB 内存创建一个**位图 (Bitmap)**，其中**数组的下标**代表电话号码的后8位，而**该位置的值 (0或1)** 代表该号码是否存在。

1. **初始化 (内存中)**

   - 在内存中申请一个 `12,500,000` 字节（即 `100,000,000` bits）的连续空间，我们称之为 `bitmap`。
   - 将这个 `bitmap` 全部初始化为 0。
   - （在C++中，`std::vector<bool>` 或 `std::bitset`（如果大小在编译时已知）可以高效实现，但`std::vector<char>` 手动管理bit是更保险的做法）。

   ```c++
   // 约 11.92 MB
   size_t bitmap_size = 12500000; 
   std::vector<unsigned char> bitmap(bitmap_size, 0); 
   ```

2. **第一遍：读取输入文件（构建位图）**

   - 打开输入的号码文件。
   - 逐行读取（例如 `0571-12345678`）。
   - 对于每一行，提取破折号 `-` 后面的8位数字字符串，并将其转换为整数 `N`（例如 `N = 12345678`）。
   - 在 `bitmap` 中设置对应的 bit 位为 1。
     - 计算字节索引：`index = N / 8`
     - 计算bit位：`bit_pos = N % 8`
     - 设置bit：`bitmap[index] = bitmap[index] | (1 << bit_pos);`
   - 重复此过程，直到读完整个输入文件。

3. **第二遍：写入输出文件（遍历位图）**

   - 打开目标输出文件（此时开始“唯一的一次写入”）。
   - 从 `i = 0` 循环到 `99,999,999`。
   - 对于每一个 `i`，检查 `bitmap` 中第 `i` 位是否为 1：
     - `index = i / 8`
     - `bit_pos = i % 8`
     - `if (bitmap[index] & (1 << bit_pos))` ...
   - 如果第 `i` 位为 1，说明这个号码存在。
   - 此时，将这个整数 `i` 格式化为8位（不足补0），并加上前缀，写入输出文件。
   - （例如，如果 `i = 4567`，则写入 `0571-00004567\n`）。

   ```c++
   // 伪代码
   FILE* output = fopen("sorted.txt", "w");
   for (int i = 0; i < 100000000; ++i) {
       if (check_bit(bitmap, i)) {
           // 格式化输出，%08d 确保了8位和前导0
           fprintf(output, "0571-%08d\n", i); 
       }
   }
   fclose(output);
   ```



### 总结

这种 **Bitmap 排序**（也称为位图索引）是处理此类问题的完美方案：

- **内存占用**：`11.92MB`，符合12MB的限制。
- **写入次数**：只对目标文件进行了一次顺序扫描写入，符合“只能写一次”的限制。
- **排序**：通过顺序遍历 `0` 到 `99,999,999` 的bit位，天然地实现了排序。
- **去重**：由于“号码不会重复出现”，我们不用担心重复设置bit位的问题，简化了处理。