

TCP Reno是继其前身TCP Tahoe之后的一个重要改进版本，它优化了网络丢包事件的处理方式，使得在发生轻微网络拥塞时，网络吞吐量不会出现断崖式下跌。Reno的核心思想是“加性增，乘性减”（Additive Increase, Multiplicative Decrease, AIMD）。



### 核心概念

在深入流程之前，必须理解两个关键的状态变量：

1. **拥塞窗口 (Congestion Window, cwnd)**: 发送方在收到确认（ACK）之前，可以连续发送的数据量（以字节或报文段MSS为单位）。这是发送方对网络拥塞程度的估计。`cwnd`越大，发送速率越快。
2. **慢启动阈值 (Slow Start Threshold, ssthresh)**: 这是一个门限值，用于区分“慢启动”阶段和“拥塞避免”阶段。



### Reno算法的四个核心阶段

Reno算法可以看作是一个由四个相互关联的阶段组成的有限状态机：

1. **慢启动 (Slow Start)**
2. **拥塞避免 (Congestion Avoidance)**
3. **快速重传 (Fast Retransmit)**
4. **快速恢复 (Fast Recovery)**

下面我们详细讲解这四个阶段是如何工作的。

------



### 详细流程

#### 1. 启动阶段：慢启动 (Slow Start)

- **目标**: 在连接刚建立或检测到严重拥塞后，快速探测网络的可用带宽，找到一个大致的拥塞点。
- **初始状态**:
  - `cwnd` 通常被初始化为一个较小的值，如 1 MSS (Maximum Segment Size)。
  - `ssthresh` 被设置为一个非常大的值。
- **工作机制**:
  - 每当发送方收到一个有效的ACK时，它就将 `cwnd` 的大小增加 1 MSS。
  - **效果**: 在一个往返时间（RTT）内，如果所有发出的报文段都得到了确认，`cwnd` 的大小就会翻倍。例如，`cwnd` 从1 -> 2 -> 4 -> 8... 呈现**指数级增长**。
- **结束条件**:
  - 当 `cwnd` 的值增长到大于或等于 `ssthresh` 时，慢启动阶段结束，进入“拥塞避免”阶段。
  - 如果在慢启动过程中发生丢包（无论是超时还是收到3个重复ACK），则进入相应的丢包处理流程。



#### 2. 稳定阶段：拥塞避免 (Congestion Avoidance)

- **目标**: 在已经接近网络容量时，小心地、线性地增加发送速率，以避免造成网络拥塞。
- **进入条件**: 当 `cwnd >= ssthresh` 时，从慢启动阶段转换而来。
- **工作机制**:
  - `cwnd` 不再指数增长，而是**线性增长**。
  - 其增长方式为：每经过一个RTT，`cwnd` 增加 1 MSS。可以近似理解为，每收到一个ACK，`cwnd` 增加 `(MSS * MSS) / cwnd`。这样确保在一个RTT内，`cwnd` 只增加约 1 MSS。
- **结束条件**:
  - 当网络发生拥塞（检测到丢包）时，拥塞避免阶段结束。

------



### 拥塞处理：Reno的核心改进

当拥塞发生时，发送方会通过两种方式检测到丢包：

1. **超时重传 (Retransmission Timeout, RTO)**: 发送方发送了一个报文段，但在规定的时间内没有收到对应的ACK。
2. **收到3个重复的ACK (Triple Duplicate ACKs)**: 发送方连续收到了三个（或更多）针对同一个报文段的ACK。这通常意味着该ACK确认的报文段之后的那个报文段丢失了。

**Reno与Tahoe最大的区别就在于它如何区分并处理这两种丢包事件。**



#### 场景一：发生超时 (Timeout) — 判断为严重拥塞

如果发生超时，Reno认为网络发生了**严重拥塞**。它的处理方式和Tahoe完全一样：

1. **将 ssthresh 的值降为当前 cwnd 的一半**：`ssthresh = cwnd / 2`。
2. **将 cwnd 的值重置为 1 MSS**。
3. **重新进入“慢启动”阶段**。

这个过程非常激进，会导致网络吞吐量瞬间降到非常低的水平。



#### 场景二：收到3个重复ACK — 判断为轻微拥塞

这是Reno算法的精髓所在。当收到3个重复ACK时，Reno认为：

- 网络只是发生了**轻微拥塞**，可能只有一个报文段丢失。
- 既然还能收到重复的ACK，说明发送方和接收方之间的网络路径依然是通的，没有必要将发送速率降到冰点。

于是，Reno执行**快速重传**和**快速恢复**：



#### 3. 快速重传 (Fast Retransmit)

- 不等超时计时器到期，**立即重传**被认为是丢失的那个报文段。



#### 4. 快速恢复 (Fast Recovery) — Reno独有

- **步骤 a (乘性减)**: 将 `ssthresh` 设置为当前 `cwnd` 的一半 (`ssthresh = cwnd / 2`)。这是“乘性减”的体现。
- **步骤 b**: 将 `cwnd` 设置为新的 `ssthresh` + 3 MSS (`cwnd = ssthresh + 3 * MSS`)。
  - 加上的这 3 MSS 是因为收到了3个重复的ACK，这表明有3个数据包已经离开了网络，并被接收方缓存了。这一步是为了“膨胀”拥塞窗口，以补偿已经离开网络的数据包。
- **步骤 c**: 接下来，每当再收到一个重复的ACK，就将 `cwnd` 增加 1 MSS。这表示又有一个数据包离开了网络。
- **步骤 d**: 当最终收到了对重传报文段的**新ACK**时（非重复的ACK），说明恢复过程完成。此时，将 `cwnd` 的值设置为第一步中计算出的 `ssthresh` 值 (`cwnd = ssthresh`)。
- **步骤 e**: **进入“拥塞避免”阶段**，而不是“慢启动”阶段。

通过这一系列操作，Reno避免了在轻微丢包时将`cwnd`重置为1，从而维持了较高的网络吞t吐量。



### 总结流程图

下面是一个简化的`cwnd`随时间变化的示意图，展示了Reno的各个阶段：

1. **指数增长** (慢启动)
2. 达到 `ssthresh` 后，转为**线性增长** (拥塞避免)
3. 发生**3个重复ACK**，`cwnd`减半，进入快速恢复，然后继续**线性增长** (拥塞避免)
4. 发生**超时**，`cwnd`骤降至1，`ssthresh`减半，重新开始**指数增长** (慢启动)

```
      ^ cwnd
      |
      |                                  /
      | ssthresh_1----------------------/----  <-- Congestion Avoidance
      |           /                  /  .
      |          /                  /   . (Triple Dup ACK)
      |         /                  /    .
      |        / ssthresh_2-------/---------  <-- Fast Recovery & Congestion Avoidance
      |       /|                /
      |      / |               /
      |     /  |              /
      |    /   | (Timeout)    /
      |   /    +-------------/
      |  /                   
      | /
      |/
      +--------------------------------------------------> Time
     Slow Start
```

总而言之，TCP Reno通过引入“快速恢复”机制，能够智能地区分严重拥塞（超时）和轻微拥塞（3个重复ACK），并采取不同的恢复策略。这使得它在大多数丢包情况下比TCP Tahoe表现得更高效，减少了网络吞吐量的剧烈波动。