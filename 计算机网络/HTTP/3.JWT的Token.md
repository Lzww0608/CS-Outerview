好的，我们来详细解析一下 JWT（JSON Web Token）是如何制作和工作的。

JWT 本质上是一个紧凑且自包含的字符串，用于在各方之间安全地传递信息（称为“声明”）。它由三部分组成，每一部分都经过 Base64Url 编码，并用点（`.`）连接起来。

一个 JWT Token 看起来像这样：

```
xxxxx.yyyyy.zzzzz
```

这三部分分别是：

1. **Header (头部)**
2. **Payload (载荷)**
3. **Signature (签名)**

下面我们逐步解析这三部分的制作过程。



### 1. Header (头部) - `xxxxx`

头部通常包含两部分信息：

- **typ (Type)**：令牌的类型，固定为 `JWT`。
- **alg (Algorithm)**：用于生成签名的加密算法，例如 `HS256` (HMAC SHA256) 或 `RS256` (RSA SHA256)。

**制作步骤：**

1. **创建一个 JSON 对象**，包含上述信息。

   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

2. **对这个 JSON 对象进行 Base64Url 编码**，得到 JWT 的第一部分。

   > **Base64Url 编码**：这是一种特殊的 Base64 编码，它将标准 Base64 中的 `+`、`/` 和 `=` 字符替换为 URL 安全的字符，使其能安全地在 URL 中传输。



### 2. Payload (载荷) - `yyyyy`

载荷是存放实际信息（称为“声明”或 "Claims"）的地方。这些声明是关于实体（通常是用户）和其他附加元数据的陈述。声明分为三种类型：

- **Registered Claims (注册声明)**：这些是预定义的一组声明，虽然不是强制性的，但推荐使用，以提供一组有用的、可互操作的声明。常见的有：
  - `iss` (Issuer)：签发者
  - `sub` (Subject)：主题（通常是用户的唯一标识符，如用户 ID）
  - `aud` (Audience)：接收者
  - `exp` (Expiration Time)：过期时间戳（超过此时间，Token 失效）
  - `nbf` (Not Before)：在此时间之前，Token 不可用
  - `iat` (Issued At)：签发时间戳
  - `jti` (JWT ID)：JWT 的唯一标识符
- **Public Claims (公共声明)**：可以由使用者随意定义，但为了避免冲突，应在 [IANA JSON Web Token Registry](https://www.google.com/search?q=https://www.iana.org/assignments/json-web-token/json-web-token.xhtml&authuser=1) 中注册，或使用包含命名空间的 URI 来定义。
- **Private Claims (私有声明)**：这是签发者和接收者共同约定的声明，用于在双方之间传递信息，不是注册声明或公共声明。例如，你可以包含用户的角色、权限等信息。

**制作步骤：**

1. **创建一个 JSON 对象**，包含你想要传递的信息。

   ```json
   {
     "sub": "1234567890",
     "name": "John Doe",
     "admin": true,
     "iat": 1516239022
   }
   ```

   **注意**：不要在载荷中存放敏感信息（如密码），因为这部分数据只是被编码，而不是加密，任何人都可以解码并读取其内容。

2. **对这个 JSON 对象进行 Base64Url 编码**，得到 JWT 的第二部分。



### 3. Signature (签名) - `zzzzz`

签名部分是 JWT 安全性的核心。它的作用是验证消息的发送者（确保是预期的签发者）并确保消息在传输过程中没有被篡改。

**制作步骤：**

1. **准备签名材料**：

   - 编码后的 Header (`xxxxx`)
   - 一个点 (`.`)
   - 编码后的 Payload (`yyyyy`)

   将它们拼接成一个字符串：`encodedHeader + "." + encodedPayload`

2. 选择一个密钥 (Secret)：

   这个密钥由服务器持有，并且绝对不能泄露给客户端或任何第三方。

3. 进行签名计算：

   使用在 Header 中指定的加密算法（例如 HS256），用密钥对准备好的签名材料进行加密计算。

   ```javascript
   // 伪代码
   signature = HMACSHA256(
     encodedHeader + "." + encodedPayload,
     secret
   );
   ```

4. **对生成的签名进行 Base64Url 编码**，得到 JWT 的第三部分。



### 总结：JWT 的生成和验证流程



#### 生成流程 (通常在服务器端)

1. 定义 Header 和 Payload 的 JSON 对象。
2. 将 Header 和 Payload 分别进行 Base64Url 编码。
3. 将编码后的 Header 和 Payload 用点 (`.`) 连接起来。
4. 使用预定义的算法 (`alg`) 和保密的密钥 (`secret`) 对连接后的字符串进行加密，生成签名。
5. 将签名进行 Base64Url 编码。
6. 最后，将编码后的 Header、Payload 和 Signature 用点 (`.`) 连接起来，形成最终的 JWT Token。



#### 验证流程 (通常在服务器端)

当服务器收到一个 JWT Token 时：

1. 服务器从请求中解析出 Token，并将其按点 (`.`) 分割成三部分。
2. 服务器取出第一部分 (Header) 并解码，以确定是哪种加密算法 (`alg`)。
3. 服务器使用**自己存储的同一个密钥 (secret)** 和相同的算法，对接收到的 `encodedHeader + "." + encodedPayload` 部分进行加密计算，生成一个新的签名。
4. 比较**新生成的签名**和接收到的 Token 的第三部分（**原始签名**）。
   - 如果两者完全匹配，说明 Token 是合法的、未被篡改的。
   - 如果两者不匹配，说明 Token 无效（可能是伪造的，或数据被篡改了）。
5. 签名验证通过后，服务器还会检查 Payload 中的注册声明，例如 `exp` (过期时间) 是否已过期。

通过这个机制，JWT 实现了紧凑、安全、自包含的信息传递。服务器无需查询数据库来验证用户信息，只需验证签名即可信任 Token 中的信息，从而提高了系统的性能和可扩展性。