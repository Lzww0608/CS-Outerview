

1.  **核心设计思想的转变**
2.  **标准的 1-RTT 握手过程（最核心）**
3.  **0-RTT 会话恢复握手过程**
4.  **与 TLS 1.2 的关键区别总结**

---

### 1. 核心设计思想的转变

在深入细节之前，理解其设计思想的转变至关重要：

*   **性能优先**：尽可能快地建立安全连接。通过减少 RTT、移除不必要的协商，实现了“默认快速”。
*   **安全加固**：
    *   **移除过时算法**：彻底废弃了静态 RSA 密钥交换、CBC 模式的加密套件、SHA1、MD5 等不安全的算法。
    *   **强制前向保密 (Perfect Forward Secrecy, PFS)**：所有密钥交换都基于临时的 Diffie-Hellman (DH) 或 Elliptic Curve Diffie-Hellman (ECDH) 算法，确保即使服务器私钥泄露，过去的会话数据也无法被解密。
    *   **更多内容加密**：尽可能早地对握手报文进行加密，包括服务器证书等在 TLS 1.2 中是明文传输的信息，大大减少了信息泄露的攻击面。

---

### 2. 标准的 1-RTT 握手过程

这是最常见也是最核心的握手流程。它仅需一次往返即可完成协商并开始传输应用数据。

**流程图示：**

```
Client                                                  Server
----------------------------------------------------------------------
ClientHello
+ key_share             -------->
+ signature_algorithms
+ supported_versions

                                                 ServerHello
                                                 + key_share
                                            {EncryptedExtensions}
                                            {Certificate*}
                                            {CertificateVerify*}
                                            {Finished}
                        <--------

{Finished}              -------->

[Application Data]      <------->      [Application Data]
```

**详细步骤分解：**

**第一步：客户端 -> 服务器 (Client's First Flight)**

客户端发起连接，发送一个 `ClientHello` 报文。这个报文非常关键，因为它包含了建立连接所需的大部分信息，体现了 TLS 1.3 “猜测性执行”的优化思想。

*   `ClientHello` 包含：
    *   **Protocol Version**: 通常会填 TLS 1.2，但在 `supported_versions` 扩展中明确表示支持 TLS 1.3。这是为了兼容不支持 1.3 的老旧中间设备。
    *   **Client Random**: 32字节的随机数。
    *   **Cipher Suites**: 支持的加密套件列表。在 TLS 1.3 中，这些套件只定义了 AEAD（带有关联数据的认证加密）算法，如 `TLS_AES_128_GCM_SHA256`，而不再包含密钥交换算法。
    *   **`key_share` 扩展 (核心)**: 这是实现 1-RTT 的关键。客户端不再等待服务器选择密钥交换算法，而是**主动猜测**服务器可能支持的 DH/ECDH 组（例如 x25519），并为这些组生成临时的公私钥对，然后将**公钥**放在这个扩展中发送给服务器。
    *   **`signature_algorithms` 扩展**: 客户端声明自己支持哪些签名算法，用于验证服务器证书和 `CertificateVerify` 消息。
    *   其他扩展，如 `supported_groups`、`server_name` (SNI) 等。

**第二步：服务器 -> 客户端 (Server's First Flight)**

服务器收到 `ClientHello` 后，如果决定使用 TLS 1.3，它会一次性地发送完成握手所需的所有信息。

1.  **密钥生成**:
    *   服务器从客户端的 `key_share` 扩展中选择一个自己也支持的 DH/ECDH 组。
    *   服务器也为该组生成自己的临时公私钥对。
    *   此时，服务器拥有自己的私钥和客户端的公钥，客户端拥有自己的私钥。服务器可以立即通过 DH 算法计算出**共享密钥 (Shared Secret)**。

2.  **密钥派生**:
    *   这个共享密钥还不能直接用于加密。双方会使用 **HKDF (HMAC-based Key Derivation Function)** 从这个共享密钥和握手过程的哈希值中派生出一系列的密钥：
        *   `client_handshake_traffic_secret` & `server_handshake_traffic_secret`: 用于加密后续的握手消息。
        *   `client_application_traffic_secret_0` & `server_application_traffic_secret_0`: 用于加密应用数据。
        *   其他密钥，如 `exporter_master_secret` 等。

3.  **发送报文**:
    *   `ServerHello`: 包含服务器选择的协议版本、加密套件、服务器随机数，以及最重要的——**`key_share` 扩展**，其中包含服务器为选定组生成的**公钥**。
    *   **【进入加密阶段】**：从这里开始，服务器发送的所有握手消息都使用 `server_handshake_traffic_secret` 进行加密。
    *   `EncryptedExtensions`: 加密的扩展，包含协商的各种参数。
    *   `Certificate` (可选): 服务器的证书链（如果需要身份验证）。
    *   `CertificateVerify`: 服务器使用其证书对应的私钥，对到目前为止的所有握手报文的哈希值进行签名。这是为了向客户端证明自己确实拥有该证书的私钥。
    *   `Finished`: 一个基于 `server_handshake_traffic_secret` 计算出的 MAC（消息认证码），用于验证到目前为止的握手过程的完整性和真实性。

**第三步：客户端完成握手**

1.  **密钥生成与验证**:
    *   客户端收到 `ServerHello` 后，从 `key_share` 扩展中获得服务器的公钥。此时客户端也拥有了计算**共享密钥**所需的所有信息，并使用 HKDF 派生出与服务器相同的全套密钥。
    *   客户端使用 `server_handshake_traffic_secret` 解密服务器发来的后续加密消息。
    *   验证服务器的 `Certificate` 和 `CertificateVerify`，确认服务器身份。
    *   验证服务器的 `Finished` 消息，确认密钥交换成功且握手未被篡改。

2.  **发送 `Finished`**:
    *   客户端也计算自己的 `Finished` 消息（使用 `client_handshake_traffic_secret`），并加密发送给服务器。

至此，1-RTT 握手完成。双方已经协商好所有参数并验证了彼此，可以立即开始使用 `application_traffic_secret` 加密和解密应用数据。

---

### 3. 0-RTT 会话恢复握手过程

0-RTT 旨在提供极致的性能，允许客户端在发送第一个 `ClientHello` 的同时，就发送加密的应用数据。

**前提条件**: 客户端和服务器之间必须有过一次成功的 1-RTT 握手。在该次握手结束时，服务器会发送一个 `NewSessionTicket` 消息给客户端，其中包含了一个**预共享密钥 (Pre-Shared Key, PSK)** 和相关参数。

**流程：**

1.  **客户端 -> 服务器**:
    *   客户端在 `ClientHello` 中包含 `pre_shared_key` 扩展，其中带有从 `NewSessionTicket` 中获取的 PSK 标识。
    *   客户端使用这个 PSK 通过 HKDF 派生出一个 `early_traffic_secret`。
    *   客户端立即使用这个密钥加密第一批应用数据（例如一个 HTTP GET 请求），并在 `early_data` 扩展中进行指示。
    *   `ClientHello` 和加密的 0-RTT 数据一同发送给服务器。

2.  **服务器响应**:
    *   服务器根据 PSK 标识找到对应的密钥，派生出 `early_traffic_secret` 并尝试解密 0-RTT 数据。
    *   如果成功，服务器处理这些数据（例如，从数据库中获取资源），并将响应包含在常规的 1-RTT 握手包之后。
    *   服务器的后续流程与 1-RTT 握手类似，它会继续完成一个标准的握手来建立新的、具有前向保密性的会话密钥。

**安全警告**: 0-RTT 的一个主要安全风险是**重放攻击 (Replay Attack)**。因为攻击者可以截获并重放 `ClientHello` 和 0-RTT 数据包，导致服务器重复执行某个操作。因此，0-RTT 只适用于那些被设计为**幂等**的请求（即重复执行不会产生副作用的请求），例如 HTTP GET 请求。在 Golang 的 `crypto/tls` 库或 OpenSSL 中，应用层需要明确开启并处理 0-RTT 的安全性。

---

### 4. 与 TLS 1.2 的关键区别总结

| 特性         | TLS 1.2                                                   | TLS 1.3                                            | 优势                        |
| :----------- | :-------------------------------------------------------- | :------------------------------------------------- | :-------------------------- |
| **握手时延** | 2-RTT (完整握手)                                          | **1-RTT** (完整握手)，支持 **0-RTT**               | **性能大幅提升**            |
| **密钥交换** | 支持静态 RSA 和 DH/ECDH                                   | **仅支持临时的 (EC)DHE**                           | **强制前向保密 (PFS)**      |
| **加密套件** | 组合式，复杂 (如 `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`) | 分离式，简洁 (如 `TLS_AES_128_GCM_SHA256`)         | **更简单，更安全**          |
| **握手加密** | `ServerHello` 之后才加密                                  | `ServerHello` 之后，服务器证书等**更多内容被加密** | **隐私性更好，安全性更高**  |
| **会话恢复** | Session ID / Session Ticket                               | **基于 PSK 的恢复机制**                            | **更高效，并与 0-RTT 结合** |
| **签名**     | `CertificateVerify` 签名内容较少                          | **签名覆盖整个握手上下文**                         | **更强的抗篡改能力**        |

总的来说，TLS 1.3 的握手过程是一个经过精心设计的、在安全性和性能之间取得卓越平衡的协议。它通过“主动猜测”和尽早加密，将握手时延压缩到了理论上的最小值，同时通过移除不安全元素和强制前向保密，构建了远超前代版本的安全基础。

如果您对某个具体环节，比如密钥派生函数 HKDF 或者 0-RTT 的安全性有兴趣，我很乐意进一步展开讨论。