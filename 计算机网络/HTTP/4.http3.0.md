

### 核心对比一览表

| 特性/方面                   | HTTP/1.1                                 | HTTP/2                                                    | HTTP/3                                       |
| --------------------------- | ---------------------------------------- | --------------------------------------------------------- | -------------------------------------------- |
| **底层协议**                | TCP                                      | TCP                                                       | **QUIC (基于 UDP)**                          |
| **多路复用**                | 不支持                                   | **支持** (单 TCP 连接上的多流)                            | **支持** (QUIC 连接上的多流)                 |
| **队头阻塞 (HOL Blocking)** | **连接级**：一个请求阻塞，后续请求都得等 | **部分解决**：请求间不阻塞，但一个 TCP 包丢失会阻塞所有流 | **彻底解决**：一个流的数据包丢失不影响其他流 |
| **头部压缩**                | 不支持                                   | **HPACK**                                                 | **QPACK**                                    |
| **协议格式**                | 文本 (Text-based)                        | **二进制 (Binary)**                                       | **二进制 (Binary)**                          |
| **连接建立延迟**            | 较高 (TCP + TLS 握手需要 2-3 RTT)        | 较高 (TCP + TLS 握手需要 2-3 RTT)                         | **极低** (QUIC 集成 TLS，仅需 0-1 RTT)       |
| **连接迁移**                | 不支持                                   | 不支持                                                    | **支持** (切换网络IP不变，连接不中断)        |
| **服务器推送**              | 不支持                                   | 支持                                                      | 支持 (但机制有所变化)                        |
| **主要目标**                | 解决 HTTP/1.0 的短连接问题               | 解决 HTTP/1.1 的性能瓶颈和队头阻塞                        | 解决 HTTP/2 中 TCP 带来的底层队头阻塞        |

------



### 核心差异详解

#### 1. 队头阻塞 (Head-of-Line Blocking, HOLB)

这是整个 HTTP 演进过程中最核心的要解决的问题。

- **HTTP/1.1 的队头阻塞 (连接级)**
  - **问题**: 在一个 TCP 连接上，请求必须是“一问一答”的串行模式。虽然 Pipelining（流水线）技术允许发送多个请求而无需等待响应，但响应必须按请求的顺序返回。如果第一个请求的响应非常慢，那么后面的所有响应都会被阻塞。
  - **比喻**: 就像超市只有一个收银通道。即使你只买一瓶水，也必须排在前面那个买了一整车东西的人后面，等他结完账你才能结。
  - **无奈的解决方案**: 浏览器为了并发，只能同时开 6-8 个 TCP 连接，但这又带来了巨大的资源开销。
- **HTTP/2 的队头阻塞 (TCP 层)**
  - **改进**: 引入了**多路复用 (Multiplexing)**。在一个 TCP 连接上，可以同时存在多个独立的**流 (Stream)**。每个请求和响应都属于一个流，它们可以交错传输，互不干扰。这解决了 HTTP/1.1 应用层的队头阻塞。
  - **新的问题**: 多路复用是“逻辑上”的。在物理传输上，所有流的数据帧都必须经过同一个 TCP 连接。TCP 协议本身要求数据包严格按序到达。如果其中一个数据包（比如属于流 A）在网络中丢失了，TCP 必须等待这个包重传并到达后，才能继续处理后续的数据包，**即使这些后续的数据包属于完全独立的流 B 和流 C**。
  - **比喻**: 超市开了多个收银员（多路复用），但所有商品都必须通过**同一辆货车**运输。如果货车在路上因为一个包裹（TCP Packet）丢失而停下等待，那么车上所有人的所有商品（所有 Stream）都无法送达。
- **HTTP/3 的解决方案 (彻底解决)**
  - **根本性变革**: HTTP/3 放弃了 TCP，转而使用基于 **UDP** 的 **QUIC** 协议。
  - **QUIC 的优势**: QUIC 也在内部实现了多路复用，但它的流是真正独立的。QUIC 的可靠性是由自己实现的，而不是依赖 UDP。当一个流的数据包丢失时，QUIC 协议栈知道只影响了这一个流，其他流的数据可以被继续正常处理和交付给上层。
  - **比喻**: 现在不仅有多个收银员，而且每个收银员都有**自己独立的运输无人机**。一个无人机（Stream）出问题，完全不影响其他无人机继续送货。



#### 2. 连接建立延迟

- **HTTP/1.1 & HTTP/2**: 都基于 TCP。建立一个安全的 HTTPS 连接需要先完成 TCP 的三次握手（1.5 RTT），然后再进行 TLS 的握手（1-2 RTT），总共需要 2-3 个 RTT（往返时延）。
- **HTTP/3**: 基于的 QUIC 协议**将 TCP 和 TLS 的功能整合**到了一起。
  - **首次连接**: 握手过程仅需 **1 RTT**。
  - **会话恢复**: 如果客户端之前连接过，QUIC 允许 **0-RTT** 的快速连接，客户端可以直接在第一个包里就带上加密的应用数据。这对移动网络等高延迟环境是巨大的提升。



#### 3. 连接迁移

- **HTTP/1.1 & HTTP/2**: 连接由四元组（源IP, 源端口, 目标IP, 目标端口）唯一标识。当你从 Wi-Fi 切换到 4G/5G 网络时，你的**源 IP 地址**会改变，导致所有 TCP 连接全部中断，必须重新建立。
- **HTTP/3**: QUIC 使用一个 64 位的**连接 ID (Connection ID)** 来标识连接，而不是 IP 地址。当你的网络切换时，IP 地址变了，但连接 ID 不变。QUIC 可以在底层无缝地将连接迁移到新的 IP 地址上，上层的 HTTP/3 完全无感，连接不会中断。这对移动设备体验是革命性的。



#### 4. 头部压缩

- **HTTP/1.1**: 无压缩。每次请求都会带上冗长的、重复的头部信息（如 `User-Agent`, `Cookie`），浪费带宽。
- **HTTP/2**: 使用 **HPACK** 算法。客户端和服务器共同维护一个动态字典，对于重复的头部只发送一个索引号，大大减少了数据量。
- **HTTP/3**: 使用 **QPACK** 算法。它是 HPACK 的升级版，主要是为了适应 QUIC 的乱序、多流特性，解决了在 HPACK 中可能出现的队头阻塞问题。

------



### 演进总结

- **HTTP/1.1 -> HTTP/2**: 主要的飞跃是从**文本协议**变为**二进制协议**，并引入了**多路复用**，解决了**应用层的队头阻塞**，大大提升了单连接的传输效率。但它依然受限于 TCP 的底层机制。
- **HTTP/2 -> HTTP/3**: 这是更底层的、革命性的变化。通过将传输层从 **TCP 更换为 QUIC (UDP)**，彻底解决了 **TCP 层的队头阻塞**，并带来了**更快的连接建立**和**无缝的连接迁移**能力，极大地优化了现代移动和不稳定网络环境下的网页浏览体验。

------



### 第一步：初次相遇 (需要 1-RTT)

当客户端**第一次**连接到一个 QUIC 服务器时，它无法实现 0-RTT。它必须先完成一次完整的握手来建立安全上下文。

1. **客户端发起连接 (Client Hello)**：客户端向服务器发送一个初始包，开始握手过程。
2. **服务器响应 (Server Hello & Certificate)**：服务器收到后，完成密钥计算，并回复自己的证书和握手信息。
3. **完成握手并发送“会话凭证” (Session Ticket)**：在这次成功的 1-RTT 握手结束时，服务器会生成一个**“会话凭证 (Session Ticket)”**。这个凭证是一个加密过的数据块，里面包含了这次会话的关键信息（如预共享密钥 PSK）。服务器将这个凭证发送给客户端。
4. **客户端存储凭证**：客户端收到这个凭证后，会将其缓存起来，以备下次连接使用。

这次初次连接，和 TLS 1.3 的 1-RTT 握手非常相似。



### 第二步：再次重逢 (实现 0-RTT)

当客户端**再次**连接同一个服务器时，神奇的事情发生了：

1. **客户端准备 0-RTT 数据**：
   - 客户端在本地缓存中找到了上次服务器给的“会话凭证”。
   - 它从凭证中提取出预共享密钥（PSK），并用这个密钥派生出一套专门用于 0-RTT 的**加密密钥**。
   - 客户端使用这套 0-RTT 密钥，**提前加密**它想要发送的第一个应用数据（例如 `GET /index.html` 请求）。
2. **客户端发送第一个包**：
   - 客户端向服务器发送它的第一个 QUIC 包。这个包是一个“复合体”，里面包含了：
     - **会话凭证 (Session Ticket)**：告诉服务器“我是老朋友，这是上次你给我的凭证”。
     - **部分握手信息 (Client Hello)**。
     - **被 0-RTT 密钥加密的应用数据** (例如 HTTP 请求)。
3. **服务器的处理**：
   - 服务器收到这个包后，用自己的密钥解密“会话凭证”，验证其有效性，并从中恢复出会话状态和预共享密钥。
   - 服务器也派生出同样的 0-RTT 解密密钥。
   - 它用这套密钥**解密**数据包中的应用数据部分，成功获得了 HTTP 请求。
   - **此时，完整的握手甚至还没完成**，但服务器已经拿到了请求，可以立刻开始处理它了（比如去数据库查询数据或读取文件）。
   - 与此同时，服务器和客户端在后台继续完成剩余的常规 1-RTT 握手，以建立一个更健壮、具备前向保密性的新会话。



### 0-RTT 的比喻

想象一下去一家需要会员卡才能进入的高级俱乐部：

- **第一次去 (1-RTT)**：你必须在前台排队，出示身份证，填表，拍照，经过完整的身份验证流程。最后，他们给了你一张**会员卡（Session Ticket）**。这个过程比较慢。
- **第二次去 (0-RTT)**：你直接走到 VIP 通道，在第一个门禁上**刷了一下你的会员卡（发送 Session Ticket），同时告诉服务员“给我来杯喝的”（发送 0-RTT 数据）**。服务员拿到你的指令后立刻去准备，而门禁系统则在后台验证你的会员卡信息。等你走到吧台，你的饮料可能已经准备好了。



### 安全风险：重放攻击 (Replay Attacks)

0-RTT 并非完美无缺，它最大的安全隐患是**重放攻击**。

- **问题所在**：因为在服务器完全验证客户端身份之前，就已经处理了它发送的数据，所以一个中间人攻击者可以截获这个 0-RTT 数据包，并**重复发送**给服务器。
- **危险场景**：如果你的 0-RTT 数据是一个非幂等操作（即每次执行都会改变服务器状态），比如 `POST /api/transfer?to=bob&amount=100`（转账100元给Bob），那么重放攻击就会导致这笔钱被转多次！
- **缓解措施**：
  1. **协议层**：QUIC 协议本身有一些防重放机制，比如要求服务器记录并拒绝在短时间内重复使用的凭证。
  2. **应用层（最关键）**：**绝对禁止**在 0-RTT 数据中发送非幂等的请求。所有主流的浏览器和 HTTP/3 客户端实现都遵循这一原则，**只允许**将 `GET`, `HEAD`, `OPTIONS` 等安全的、幂等的 HTTP 方法用于 0-RTT。像 `POST`, `PUT`, `DELETE` 等请求，必须等待完整的 1-RTT 握手成功后才能发送。



### 总结

|              | **首次连接 (1-RTT)**                  | **后续连接 (0-RTT)**                             |
| ------------ | ------------------------------------- | ------------------------------------------------ |
| **客户端**   | 正常发起握手                          | **发送包含 Session Ticket 和加密请求的初始包**   |
| **服务器**   | 正常完成握手，**颁发 Session Ticket** | **验证 Ticket，解密 0-RTT 数据并立即处理**       |
| **延迟**     | 1-RTT                                 | **0-RTT**                                        |
| **关键技术** | TLS 1.3 握手                          | **会话凭证 (Session Ticket) 和预共享密钥 (PSK)** |
| **安全限制** | -                                     | **只能用于幂等请求 (如 GET)，防止重放攻击**      |

通过这种机制，HTTP/3 在高延迟的移动网络环境下，能够显著减少页面加载的“可感知延迟”，为用户带来更流畅的体验。