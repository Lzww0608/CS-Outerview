

1. **（历史）为什么 Linux 在近20年里 没有 采用 ARC/LIRS？**
2. **（现在）Linux 真的 还在用 2Q 吗？（剧透：它正在被替换）**

------



### 1. 为什么 Linux 长期坚持使用 2Q 思想（而非 ARC/LIRS）？

首先，需要精确一点：Linux 内核使用的不是 1994 年论文中原版的 2Q 算法，而是受其思想启发的、更简单的变体，通常称为 **"LRU 2-List"（双链表LRU）**。

这个机制就是你所熟知的 **Active List (活跃链表)** 和 **Inactive List (非活跃链表)**。

- `Inactive List` 约等于 2Q 的 `A1`（见习队列）。
- `Active List` 约等于 2Q 的 `Am`（主队列）。

新页面进入 `Inactive` 列表，当它被再次访问时，就有资格“晋升”到 `Active` 列表。这个设计**只解决一个核心问题：抵抗扫描（Scan-Resistance）**。

在长达20年的时间里（从2.6内核到5.x内核），这个机制之所以没有被 ARC、LIRS 等“更优”算法替换，原因非常现实：



#### (1) 开销与锁竞争：内核的“第一性原理”

这是**最重要**的原因。ARC 或 LIRS 算法对于**应用程序（如数据库ZFS）来说是绝佳的，但对于操作系统内核**来说可能是灾难性的。

- **ARC/LIRS 的开销：**
  - **高计算开销：** ARC (Adaptive Replacement Cache) 需要维护四个链表（LRU hot, LFU hot, LRU ghost, LFU ghost）并动态调整一个“幽灵”列表的分界点`p`。LIRS (Low Inter-reference Recency Set) 也需要维护复杂的元数据（IRR, LIR）。
  - **高频操作：** 这些算法**在每一次缓存命中（Hit）时**都需要执行相对复杂的操作（更新频率、调整链表、移动数据）。
- **内核的现实：**
  - 内核的页面置换代码是在**极其关键的路径（Critical Path）**上运行的。它可能在处理缺页中断时，或者在内存回收（kswapd）时执行。
  - **CPU 消耗是致命的：** 你不能在每次内存访问时都花费大量 CPU 周期去维护复杂的缓存数据结构。Active/Inactive 列表的开销极低：大多数命中（Hit）在 Active 列表上只需要一次链表移动（`O(1)`），在 Inactive 列表上的晋升也只是两次链表操作。
  - **锁竞争是瓶颈：** 传统的 Linux LRU 链表因为一个全局的 `lru_lock` 已经饱受诟病。如果换成 ARC，这个锁需要保护的数据结构（四个链表+动态参数`p`）将变得复杂得多，锁的粒度更难细化，锁定的时间也会更长，这在现代几百个核心的服务器上是不可接受的。



#### (2) 内存开销：幽灵列表的代价

ARC 和 LIRS 的一个关键特性是它们会维护“幽灵列表”（Ghost Lists）。这些列表存储的是**已经被淘汰出缓存的“键”**（在OS里就是页面标识符），用于判断这些数据如果“还活着”的话，它们的访问模式是怎样的。

- **应用程序（如 ZFS）：** 没问题。ZFS 的 ARC 缓存的是数据块，用数据块的地址（checksum）作为“键”存入幽灵列表，开销可控。
- **操作系统（如 Linux）：** 这是巨大的开销。如果你的服务器有 1TB 内存，可能有数亿个内存页。如果你要为这些页维护一个同样规模的幽灵列表，**这些元数据本身就会消耗掉几十 GB 的宝贵内存**，而这些内存本可以用来缓存真实的数据。



#### (3) 算法的通用性 vs. 特异性

Linux 内核是一个**通用**操作系统。它必须同时处理各种极端的工作负载：

- 数据库（随机读写，ARC/LIRS 表现极好）
- 大规模编译、数据分析（顺序扫描，2Q/Active-List 表现极好）
- 桌面应用（突发性、局部性强，LRU 表现极好）
- Web服务器（高并发小文件）

ARC 和 LIRS 在特定负载（如数据库）上可能表现完美，但在其他负载上可能持平甚至更差（因为开销大）。而 "Active/Inactive" 这种简单的 2Q 变体，虽然不是对所有负载都是“最优”的，但它对所有负载都是**“足够好且可预测”**的，并且它**完美地解决了 LRU 最大的痛点（扫描污染）**。

------



### 2. 划时代变革：MGLRU（多代 LRU）登场

你提问的时机非常好。**Linux 一直使用 2Q 变体”这个时代正在结束。**

从 **Linux 5.15 内核**（2021年底）开始，Google 开发并合入了全新的页面置换算法——**MGLRU (Multi-Generational LRU)**。

在 2023-2025 年，主流的发行版（如 Ubuntu 24.04, Fedora 39+）已经开始**默认启用 MGLRU**。



#### (1) 为什么 Active/Inactive（2Q变体）最终还是被淘汰了？

因为它在现代硬件和工作负载下也“不够用”了：

1. **扩展性差：** 它的 `lru_lock` 锁竞争问题在超多核（96+ cores）和超大内存（TB+）的 NUMA 系统上已成为严重瓶EEG。
2. **决策粗糙：** 它只有“活跃”和“非活跃”两个状态，无法精细区分“非常热”、“比较热”、“有点冷”、“非常冷”的数据。
3. **回收效率低：** 当内存紧张时，内核的回收机制（kswapd）需要疯狂地扫描这两个巨大的链表，CPU 消耗巨大，而且常常做出错误决策（比如淘汰了“比较热”的 `Active` 页面，而不是“非常冷”的 `Inactive` 页面）。



#### (2) 为什么是 MGLRU 胜出了（而不是 ARC/LIRS）？

MGLRU 被誉为“过去20年内核内存管理最大的变革”，它成功合入主线，是因为它**在不引入 ARC/LIRS 致命开销的前提下，实现了比它们更优的性能**。

MGLRU 的核心思想是：

1. **不再是两个链表，而是“多代” (Multi-Generational)：** 它为每个内存节点（NUMA node）维护了多个“代”（Generations）的链表，代表页面的“年龄”。
2. **高效的“老化”：** 它不再是在每次访问时都去移动页面。而是周期性地、增量地扫描页面。
3. **扫描与决策：**
   - 它扫描最老一代（Oldest Generation）的页面。
   - 如果一个页面被访问过（通过`Accessed`位判断），就把它“晋升”到最新一代（Youngest Generation）。
   - 如果一个页面未被访问过，它就被“老化”（留在原地，等待下一轮）或者最终被淘汰。

**MGLRU 的关键优势：**

- **极低的命中开销：** 缓存命中（Hit）时**几乎是零开销**。它不像 LRU/ARC 那样需要在每次命中时去移动链表或更新计数器。它只是在硬件层面设置一个 `Accessed` 位，这个开销基本为零。
- **高效的回收：** 当需要回收内存时，它**只需要扫描最老的一代**，这是一个很小的链表，而不是像老算法那样扫描整个 `Active` 和 `Inactive` 列表。
- **精细的决策：** 通过“多代”，它能非常精细地识别出哪些页面是“持续热”，哪些是“突发热”，哪些是“彻底冷”。

根据 Google 和 Meta 的实测数据，在生产环境中启用 MGLRU 带来了巨大的性能提升：

- 在 Android 上，低内存杀死（LMK）减少了 40%。
- 在 Meta 的服务器上，CPU 消耗显著降低，应用延迟大幅改善。



### 总结

1. Linux 长期使用 2Q 的**变体** (Active/Inactive List)，是因为它**用最小的开销（`O(1)`、低锁竞争）解决了 LRU 最大的问题（扫描污染）**。
2. 它没有采用 ARC/LIRS，是因为这些算法**对于内核来说“太昂贵”**（高CPU开销、高内存开销、高锁竞争）。
3. 这个时代已经结束。从 5.15 内核开始，**MGLRU 正在全面取代**老的 Active/Inactive 算法，因为它实现了比 ARC 更优的性能，同时保持了比 2Q 变体更低的（命中）开销。