MGLRU (多代 LRU) 算法的流程是一个精巧的“生产者-消费者”模型，它主要由两个并行的核心流程组成：**老化 (Aging)** 和 **驱逐 (Eviction)**。

以下是这个算法的详细流程，以及每一步使用的关键数据结构：



### 一、核心数据结构

在深入流程之前，必须先了解几个关键的数据结构：

1. **lrugen->folios[] (核心)**
   - **数据结构:** 一个**环形缓冲区（Circular Buffer）数组，数组的每个元素都是一个页表（Folio）的双向链表**。
   - **作用:** 这是 MGLRU 的“代”列表本身。如果 `MAX_NR_GENS` 是 16，那么就有 16 个链表。`lrugen->folios[0]` 可能代表“第 5 代”，`lrugen->folios[1]` 代表“第 6 代”，以此类推。一个页面（folio）物理上只存在于这 16 个链表之一中。
2. **lrugen->max_seq 和 lrugen->min_seq[]**
   - **数据结构:** **整数（Integer）**。
   - **作用:** 这两个整数定义了一个“滑动窗口”。`max_seq` 是最新一代的编号，`min_seq` 是最老一代的编号。它们是单调递增的。
   - **索引方式:** 页面真正存储在哪个链表，是通过 `代号 % MAX_NR_GENS` 来计算索引的。例如，`max_seq` 为 20，`MAX_NR_GENS` 为 16，那么最新的页面在 `lrugen->folios[20 % 16]` 也就是 `lrugen->folios[4]` 链表中。
3. **folio->flags (中的“代计数器”)**
   - **数据结构:** **位字段（Bitfield）**，位于每个页面（folio）结构体内部。
   - **作用:** 在页面自身上“贴标签”，记录它当前属于哪一代（存储的是 `max_seq % MAX_NR_GENS` 的计算结果）。这使得检查一个页面的“代”变得非常快，无需遍历链表。
4. **lruvec_memcg()->mm_list**
   - **数据结构:** **双向链表**。
   - **作用:** 存储了属于同一个内存控制组（memcg）的所有进程的地址空间结构（`mm_struct`）。“老化”流程需要通过这个列表来找到要扫描的页表。
5. **布隆过滤器 (Bloom Filters)**
   - **数据结构:** **位数组（Bit Array）** 和一组哈希函数。
   - **作用:** 一个高效的、概率性的集合。用于在“驱逐”和“老化”两个流程之间传递“哪些内存块(PMD)可能是热点”的信息。
6. **PID 控制器**
   - **数据结构:** 一组**整型/浮点型变量**（用于存储 P、I、D 三个分量以及误差和积分值）。
   - **作用:** 一个算法实现，它根据历史的“再次缺页率”(Refault) 来作为反馈信号，动态调整驱逐策略。

------



### 二、核心流程详解

#### 流程一：老化 (Aging) - “生产者”

**目标：** 找出最近被访问过的“热”页面，并将它们移动到“最新一代”。

1. **触发时机：**
   - （A）周期性地被唤醒。
   - （B）被“驱逐”流程通过布隆过滤器“告知”有热点区域时。
2. **步骤 (A)：扫描所有进程 (Page Table Walk)**
   - **动作：** 遍历 `lruvec_memcg()->mm_list`（**链表**），获取一个进程的 `mm_struct`。
   - **动作：** 扫描该进程的页表（Page Table），检查 PTE（页表项）的“已访问位”(Accessed Bit)。
   - **判断：** 如果“已访问位”为 1：
     - **数据结构操作 1：** 清除 PTE 的“已访问位”。
     - **数据结构操作 2：** 获取该页面（folio），读取它当前的 `folio->flags`（**位字段**）中的“代计数器”。
     - **数据结构操作 3：** 如果它属于一个“老代”，则将其“晋升”：
       1. 更新 `folio->flags`（**位字段**）为最新的代号（`max_seq % MAX_NR_GENS`）。
       2. 将其从 `lrugen->folios[旧索引]`（**链表**）中移除。
       3. 将其添加到 `lrugen->folios[新索引]`（**链表**）的头部。
3. **步骤 (B)：扫描热点区域 (Bloom Filter Walk)**
   - **动作：** 这是“老化”流程的一个优化。它不盲目扫描所有进程，而是先检查**布隆过滤器**。
   - **判断：** 如果布隆过滤器显示某个内存块(PMD)“可能”是热点：
     - **动作：** “老化”流程会**仅**扫描这个高概率的热点内存块的页表，执行与步骤(A)中相同的“晋升”操作。
4. **步骤 (C)：创建新一代**
   - **动作：** 当“老化”流程完成一轮扫描，或者当 `max_seq - min_seq` 接近窗口最小值时，它会递增 `lrugen->max_seq`（**整数**）。
   - **效果：** 这在逻辑上“创建”了一个新的“最新一代”。（物理上，它只是让 `(max_seq + 1) % MAX_NR_GENS` 对应的那个链表成为了新的“最新”链表，这个链表里可能还装着最老的页面，等待被“驱逐”流程清空）。



#### 流程二：驱逐 (Eviction) - “消费者”

**目标：** 在内存不足时，从“最老一代”中回收页面。

1. **触发时机：**
   - 内核的 kswapd 进程或直接内存回收（Direct Reclaim）被唤醒，发现内存压力大。
2. **步骤 (A)：选择目标**
   - **动作：** 查看 `lrugen->min_seq[]`（**整数**），确定“最老一代”的代号。
   - **数据结构操作：** 计算出最老一代的索引 `idx = min_seq % MAX_NR_GENS`。
   - **动作：** 定位到 `lrugen->folios[idx]`（**链表**），准备从这个链表的尾部开始扫描。
3. **步骤 (B)：智能决策 (PID 控制器)**
   - **背景：** 在 `lrugen->folios[idx]` 链表中，可能既有匿名页（程序数据）也有文件页（缓存）。
   - **判断：** 该优先驱逐哪一种？
   - **数据结构操作：** 此时会查询 **PID 控制器**（**算法/变量**）。
   - **动作：** PID 控制器会根据历史的“再次缺页率”统计数据，给出一个建议（例如：“文件页的再次缺页率更低，优先驱逐文件页”）。
4. **步骤 (C)：执行驱逐**
   - **动作：** 从 `lrugen->folios[idx]`（**链表**）尾部取出一个页面（folio）。
   - **动作：**（Rmap Walk）最后检查一次该页面的“已访问位”。
   - **判断 1 (页面是热的)：** 如果“已访问位”为 1（或在检查中发现它很“热”）：
     - **动作：** 这是“最后一次拯救机会”。该页面被“晋升”。
     - **数据结构操作：** 执行与“老化”流程[步骤(A)]中相同的操作，将其移动到“最新一代”（`lrugen->folios[max_seq % MAX_NR_GENS]` 链表）。
     - **(反馈) 数据结构操作：** **这是关键！** 此时，驱逐流程会认为这个页面所在的内存块(PMD)很“热”，于是它将这个 PMD 的地址添加到**布隆过滤器**（**位数组**）中，以便“老化”流程[步骤(B)]能快速跟进扫描。
   - **判断 2 (页面是冷的)：** 如果“已访问位”为 0：
     - **动作：** 驱逐（回收）这个页面。
     - **数据结构操作：** 将其从 `lrugen->folios[idx]`（**链表**）中彻底移除。
5. **步骤 (D)：消耗一代**
   - **动作：** 当 `lrugen->folios[idx]`（**链表**）中的所有页面都被驱逐或晋升后，这个链表变空了。
   - **数据结构操作：** 系统递增 `lrugen->min_seq`（**整数**）。
   - **效果：** “滑动窗口”向前移动，原先的“次老一代”现在成为了“最老一代”，成为下一个驱逐目标。