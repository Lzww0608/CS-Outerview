# 什么是CPU中断，CPU中断发生了哪些事情？



## 1. 中断请求

### CPU中断请求分为两类：

**外部中断**：一个硬件设备（如网卡、硬盘、键盘、定时器）完成了某项任务或需要CPU的关注。它会通过一个称为**中断请求线 (IRQ)** 的物理线路向CPU发送一个电信号。

**内部中断**：CPU内部在执行指令时发生了一些特殊事件。

- **软件中断**：程序主动调用了系统调用（如 `INT 0x80`），希望操作系统提供服务（如读文件）。
- **异常**：发生了错误（如除以零、访问了无效内存地址——即页错误）。



## 2. CPU响应与检测

CPU在每执行完一条指令后，都会检查中断控制器是否有待处理的中断信号。如果检测到中断，并且该中断的优先级高于当前正在运行的任务，CPU就会响应。



## 3. 保存现场 (Save Context)

这是至关重要的一步，为了能在中断处理完后能回到原来的地方继续执行。CPU会做以下事情：

1. **中断当前的执行流**。
2. 将当前进程的关键上下文信息**压入内核栈 (Kernel Stack)** 中。这些信息至少包括：
   - **程序计数器 (Program Counter, PC)**：也叫指令指针 (Instruction Pointer, IP)，它指向下一条将被执行的指令的内存地址。
   - **状态寄存器 (Status Register)**：包含了当前CPU的各种状态标志（如进位、零标志等）。
   - **通用寄存器 (General-Purpose Registers)**：如 `EAX`, `EBX` 等，它们保存了当前程序运行中的中间数据。



## 4. 查找中断服务例程 (ISR)

CPU需要知道由谁来处理这个中断。它通过**中断向量表 (Interrupt Vector Table, IVT)** 来找到对应的处理程序。

- 每个中断都有一个唯一的编号（中断向量号）。
- CPU使用这个编号作为索引，在中断向量表中查找到对应的**中断服务例程 (Interrupt Service Routine, ISR)** 的入口地址。中断向量表是操作系统在启动时初始化好的，它记录了所有可能的中断类型和其处理函数的对应关系。



## 5. 执行中断服务例程 (Execute ISR)

CPU跳转到ISR的地址，开始执行处理中断的代码。这部分代码属于**操作系统内核**。

- **识别中断源**：ISR首先可能需要查询中断控制器，确定中断的具体来源（例如，是键盘的哪个按键被按下了）。
- **处理中断**：执行相应的处理逻辑。例如：
  - 如果是键盘中断，就从键盘的端口读取数据，放入缓冲区。
  - 如果是磁盘读完成中断，就通知等待数据的进程数据已准备好。
  - 如果是定时器中断，就更新系统时间，并进行进程调度。
- **发送结束信号**：ISR处理完成后，会向中断控制器发送一个“中断结束 (End of Interrupt, EOI)”信号，表示中断已处理完毕，可以接收新的中断了。

----------------------------------------------------------------------------------------------------------------------------------------------------

**这一步在Linux中被明确地一分为二：**

- **中断上半部 (Top Half)**
  - **就是第5步“执行ISR”的开始部分，也是最紧急的部分。**
  - 它在中断被硬件触发后**立即执行**。
  - 它的工作严格遵守“快进快出”原则：比如，从网卡里读取一个状态码，清除中断标志，然后**把一个耗时的任务（如下半部）注册到内核的待办列表里**。
  - **上半部执行完毕，它本身就结束了，但整个中断事件的处理还没完。**
- **中断下半部 (Bottom Half)**
  - **是第5步中被上半部“推迟”执行的、耗时的那部分工作。**
  - 它**不会**在中断发生时立即执行，而是在上半部执行完毕后的某个安全时刻，由内核调度执行。
  - 它负责处理那些复杂的任务，比如完整地处理一个网络数据包。
  - 下半部执行时，CPU是**可以响应新中断**的，所以系统不会被卡住。

------



## 6. 恢复现场 (Restore Context)

当中断服务例程执行完毕后，系统会执行一条特殊的返回指令（如 `IRET`）。

1. CPU会将之前压入内核栈中的**所有寄存器状态**和**程序计数器 (PC)** 依次**弹出 (pop)**，恢复到CPU的各个寄存器中。
2. 这个操作完成后，CPU的状态就和被中断前一模一样了。



## 7. 返回原程序执行

由于程序计数器 (PC) 已经被恢复，CPU会从之前被中断的指令的**下一条**开始继续执行原来的程序。整个过程对被中断的程序来说是完全透明的。