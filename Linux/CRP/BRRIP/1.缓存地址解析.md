

## 📍 缓存地址解析：三段式设计

### 地址结构示例

假设我们有：
- **缓存大小**：64KB
- **块大小**：64字节
- **相联度**：8路
- **组数**：128组 (64KB / 64B / 8路 = 128)

那么一个64位地址被分解为：

```
内存地址：0x0000_1234_5678_9ABC

┌────────────────────────────────────────────────────┐
│  TAG (52位)  │ SET_INDEX (7位) │ OFFSET (6位)     │
│              │                  │                   │
│  标识是哪个块 │  选择哪个组      │  块内第几个字节   │
└────────────────────────────────────────────────────┘
```



### 🎯 三部分的具体作用

#### **1️⃣ OFFSET（块内偏移）**
```cpp
offset_bits_ = log2(block_size_bytes);  // 64字节 → 6位
```

**作用**：定位到块内的具体字节

```
例如：OFFSET = 0b101010 (42)
→ 表示要访问这个缓存块的第42个字节

┌─────────────────────────────────────┐
│ Cache Block (64 bytes)              │
│ [0][1][2]...[42]...[63]            │
│              ↑ 要访问这里            │
└─────────────────────────────────────┘
```

**为什么不需要在缓存逻辑中使用？**
- 缓存是以**整块**为单位管理的
- OFFSET只在CPU读取具体数据时才用到
- 缓存替换策略不关心块内哪个字节

---

#### **2️⃣ SET_INDEX（组索引）**
```cpp
set_index = (address >> offset_bits_) & ((1ULL << set_index_bits_) - 1);
```

**作用**：将内存地址映射到具体的缓存组

```
内存地址空间                    缓存组
┌──────────────┐               ┌──────┐
│ 0x0000_xxxx  │──┐            │ Set 0│ (8路)
│ 0x0040_xxxx  │  │  Hash映射   │ Set 1│ (8路)
│ 0x0080_xxxx  │──┼────────→   │ Set 2│ (8路)
│ 0x00C0_xxxx  │  │            │  ...  │
│     ...      │──┘            │Set127│ (8路)
└──────────────┘               └──────┘

计算方式：
address = 0x1234_5680
offset_bits = 6
set_index_bits = 7

set_index = (0x1234_5680 >> 6) & 0b111_1111
         = 0x48D15 & 0x7F
         = 0x15 = 21
→ 这个地址应该去第21号组查找
```

**为什么需要SET_INDEX？**
- **降低查找复杂度**：不需要搜索整个缓存，只搜索一个组
- **均匀分布**：通过地址低位哈希，让不同地址均匀分布到各组
- **组相联**：在SET_INDEX确定的组内进行8路（或N路）查找

---

#### **3️⃣ TAG（标签）**
```60:61:CRP/src/BRRIP/brrip_cache.cpp
    set_index = (address >> offset_bits_) & ((1ULL << set_index_bits_) - 1);
    tag = address >> (offset_bits_ + set_index_bits_);
```

**作用**：在同一个组内区分不同的内存块

```
为什么需要TAG？
因为多个内存地址会映射到同一个组！

例如：组2可能同时缓存这些地址的数据
┌──────────────────────────────────────┐
│  Set 2 (8-way)                       │
├────────┬─────┬──────┬────────────────┤
│ Way 0  │Valid│ TAG  │ Data[64B]      │
│        │  1  │0x123 │ [...........]   │ ← 来自地址0x123_002_80
├────────┼─────┼──────┼────────────────┤
│ Way 1  │  1  │0x456 │ [...........]   │ ← 来自地址0x456_002_80
├────────┼─────┼──────┼────────────────┤
│ Way 2  │  0  │  -   │ [...........]   │ ← 空闲
├────────┼─────┼──────┼────────────────┤
│  ...   │ ... │ ...  │     ...        │
└────────┴─────┴──────┴────────────────┘

查找过程：
1. SET_INDEX=2 → 定位到组2
2. 在组2的8路中，逐个比较TAG
3. 找到TAG=0x123且Valid=1 → 命中！
```

查找代码就体现了这个过程：

```65:78:CRP/src/BRRIP/brrip_cache.cpp
bool BRRIPCache<RRPV_M_BITS>::access(uint64_t address) {
    uint64_t tag;
    size_t set_index;
    parseAddress(address, tag, set_index);

    assert(set_index < num_sets_ && "Invalid set index");

    auto& target_set = sets_[set_index];
    auto way = target_set.findWay(tag);

    if (way.has_value()) {
        target_set.accessWay(way.value());
        hit_count_.fetch_add(1, std::memory_order_relaxed);
        return true;
```

---

##  Buckets 数据结构的作用

让我查看buckets的定义：

### 🎯 Buckets：高效的RRPV索引结构

**定义**：
```cpp
std::vector<std::vector<size_t>> buckets_;  // buckets[r] 存储所有 RRPV=r 的way索引
```

**作用**：将相同RRPV值的缓存行组织在一起，实现O(1)查找

---

### 📊 Buckets 工作原理图解

假设一个8路组相联缓存，RRPV使用2位（0-3）：

```
初始状态：
┌────────────────────────────────────────────────────┐
│ Ways (实际缓存行)                                   │
├──────┬──────┬──────┬──────────────────────────────┤
│ Way0 │Valid │ RRPV │ TAG │ Data                    │
│      │  1   │  0   │0x12 │ [..................]    │
├──────┼──────┼──────┼─────┼─────────────────────────┤
│ Way1 │  1   │  2   │0x34 │ [..................]    │
├──────┼──────┼──────┼─────┼─────────────────────────┤
│ Way2 │  1   │  0   │0x56 │ [..................]    │
├──────┼──────┼──────┼─────┼─────────────────────────┤
│ Way3 │  1   │  3   │0x78 │ [..................]    │
├──────┼──────┼──────┼─────┼─────────────────────────┤
│ Way4 │  1   │  1   │0x9A │ [..................]    │
├──────┼──────┼──────┼─────┼─────────────────────────┤
│ Way5 │  1   │  3   │0xBC │ [..................]    │
├──────┼──────┼──────┼─────┼─────────────────────────┤
│ Way6 │  0   │  -   │  -  │ [..................]    │
├──────┼──────┼──────┼─────┼─────────────────────────┤
│ Way7 │  1   │  2   │0xDE │ [..................]    │
└──────┴──────┴──────┴─────┴─────────────────────────┘

对应的 Buckets 索引结构：
┌────────────────────────────────────┐
│ buckets_[0] = {0, 2}              │ ← RRPV=0的way有：Way0, Way2
├────────────────────────────────────┤
│ buckets_[1] = {4}                 │ ← RRPV=1的way有：Way4
├────────────────────────────────────┤
│ buckets_[2] = {1, 7}              │ ← RRPV=2的way有：Way1, Way7
├────────────────────────────────────┤
│ buckets_[3] = {3, 5}              │ ← RRPV=3的way有：Way3, Way5
└────────────────────────────────────┘

辅助数据：
rrpv_presence = 0b1111 (所有RRPV值0-3都存在)
max_rrpv = 3           (当前最大RRPV值)
```

---

### ⚡ Buckets 的三大优势

#### **1. 快速查找Victim（O(1)复杂度）**

**没有buckets的情况**：
```cpp
// 需要遍历所有way，时间复杂度O(N)
size_t findVictimWay() {
    uint8_t max_rrpv = 0;
    // 第一遍：找出最大RRPV值
    for (size_t i = 0; i < ways_.size(); i++) {
        if (ways_[i].valid && ways_[i].rrpv > max_rrpv) {
            max_rrpv = ways_[i].rrpv;
        }
    }
    // 第二遍：找出所有RRPV等于max的way
    std::vector<size_t> candidates;
    for (size_t i = 0; i < ways_.size(); i++) {
        if (ways_[i].valid && ways_[i].rrpv == max_rrpv) {
            candidates.push_back(i);
        }
    }
    return candidates[rand() % candidates.size()];
}
```

**有buckets的情况**：
```107:113:CRP/src/BRRIP/cache_set.cpp
    // 现在max_rrpv == RRPV_MAX，从max_rrpv bucket中随机选择victim
    auto& candidates = buckets_[max_rrpv];
    
    // 使用C++11随机数生成器
    static thread_local std::mt19937 gen(std::random_device{}());
    std::uniform_int_distribution<size_t> dist(0, candidates.size() - 1);
    size_t victim_idx = candidates[dist(gen)];
```

**性能对比**：O(N) → O(1) ✨

---

#### **2. 高效的RRPV更新**

当访问命中时，需要将某个way的RRPV从旧值改为0：

```130:154:CRP/src/BRRIP/cache_set.cpp
void CacheSet<RRPV_M_BITS>::accessWay(size_t way_index) {
    // write lock
    std::unique_lock<std::shared_mutex> writeLock(*mtx_);
    auto& line = ways_[way_index];
    uint8_t old_rrpv = line.rrpv;
    line.rrpv = 0; // reset to 0
    line.valid = true;

    // remove from old bucket, add to bucket '0'
    auto& old_bucket = buckets_[old_rrpv];
    old_bucket.erase(std::remove(old_bucket.begin(), old_bucket.end(), way_index), old_bucket.end());
    if (old_bucket.empty()) {
        rrpv_presence &= ~(1 << old_rrpv);
        // if old_rrpv == max_rrpv, update
        if (old_rrpv == max_rrpv) {
            while (max_rrpv > 0 && !(rrpv_presence & (1 << max_rrpv))) {
                max_rrpv--;
            }
        }
    }

    buckets_[0].push_back(way_index);
    rrpv_presence |= 1;
    max_rrpv = std::max<uint8_t>(0, max_rrpv);
}
```

**操作流程**：
```
1. 从旧bucket中移除way索引
2. 添加到新bucket
3. 更新位图标记
```

---

#### **3. 批量Age-Up操作**

RRPV的核心特性：当没有RRPV=MAX的行时，所有行的RRPV要递增：

```85:105:CRP/src/BRRIP/cache_set.cpp
    // RRPV Age-Up机制：如果max_rrpv < RRPV_MAX，递增所有行的RRPV直到有行达到RRPV_MAX
    while (max_rrpv < RRPV_MAX) {
        // 遍历所有当前max_rrpv的行，将它们的RRPV递增
        for (uint8_t rrpv = 0; rrpv <= max_rrpv; ++rrpv) {
            auto& bucket = buckets_[rrpv];
            if (!bucket.empty()) {
                // 将这个bucket中的所有way移动到rrpv+1
                auto& next_bucket = buckets_[rrpv + 1];
                for (size_t way_idx : bucket) {
                    ways_[way_idx].rrpv++;
                    next_bucket.push_back(way_idx);
                }
                // 更新位图
                rrpv_presence |= (1 << (rrpv + 1));
                // 清空当前bucket
                bucket.clear();
                rrpv_presence &= ~(1 << rrpv);
            }
        }
        max_rrpv++;
    }
```

**动画演示**：
```
Age-Up前：max_rrpv=2, RRPV_MAX=3
buckets_[0] = {0, 2}
buckets_[1] = {4}
buckets_[2] = {1, 7}
buckets_[3] = {}      ← 空的！需要Age-Up

Age-Up后：max_rrpv=3
buckets_[0] = {}
buckets_[1] = {0, 2}  ← 从bucket[0]移过来
buckets_[2] = {4}     ← 从bucket[1]移过来
buckets_[3] = {1, 7}  ← 从bucket[2]移过来，现在可以驱逐了！
```

---

## 🎓 总结对比表

| 概念          | 作用           | 类比                     |
| ------------- | -------------- | ------------------------ |
| **OFFSET**    | 定位块内字节   | 📖 书的第几页的第几行     |
| **SET_INDEX** | 选择缓存组     | 🗄️ 文件柜的第几个抽屉     |
| **TAG**       | 区分同组内的块 | 🏷️ 抽屉里每个文件夹的标签 |
| **Buckets**   | RRPV值索引     | 📊 按优先级分类的任务列表 |

**查找流程完整示意**：
```
内存地址 0x1234_5680
    ↓ parseAddress()
┌─────────┬────────────┬────────┐
│TAG=0x123│SET_INDEX=21│OFFSET=0│
└─────────┴────────────┴────────┘
           ↓
    访问第21号组（8路）
           ↓
    逐路比较TAG
           ↓
    找到TAG=0x123的way → 命中！
           ↓
    accessWay() → 更新buckets
    将该way从buckets_[old_rrpv]移到buckets_[0]
```

这种设计既保证了缓存查找的效率，又优化了替换策略的性能！🚀