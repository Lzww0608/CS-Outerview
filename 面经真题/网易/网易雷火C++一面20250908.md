# 网易雷火C++一面20250908
## 给你4个点和坐标，再给一个点P，怎么判定P在4个点之间

这个方法无论对凸四边形还是凹四边形都适用，是解决这个问题的**最稳健**的方法。



#### 核心思想



将四边形 `ABCD` 沿着一条对角线（例如 `AC`）切割成两个三角形 `△ABC` 和 `△ADC`。如果点 `P` 在这两个三角形中的**任意一个**内部，那么它就在四边形内部。

这样，问题就从“判断点是否在四边形内”简化成了两次“判断点是否在三角形内”。

#### 具体步骤

1. **选择对角线**：选择一条对角线，例如连接 `A` 和 `C`。
2. **进行两次测试**：
   - 判断点 `P` 是否在 `△ABC` 内部。
   - 如果不在，再判断点 `P` 是否在 `△ADC` 内部。
3. **得出结论**：只要其中一个测试结果为“是”，那么点 `P` 就在四边形 `ABCD` 内部。如果两个都不是，则 `P` 在外部。

#### 如何判断点在三角形内？

这里最常用且最高效的是**向量叉积法**。 假设三角形的顶点按逆时针顺序排列为 `A, B, C`。如果点 `P` 在三角形内部，那么它必须同时满足：

- 在向量 `AB` 的左侧。
- 在向量 `BC` 的左侧。
- 在向量 `CA` 的左侧。

“在向量左侧”可以通过二维向量的**叉积（Cross Product）**来判断。对于向量 `v1 = (x1, y1)` 和 `v2 = (x2, y2)`，它们的叉积为 `x1*y2 - x2*y1`。

- **叉积 > 0**：`v2` 在 `v1` 的逆时针方向（左侧）。
- **叉积 < 0**：`v2` 在 `v1` 的顺时针方向（右侧）。
- **叉积 = 0**：两个向量共线。

所以，判断 `P` 是否在 `△ABC` 内，就是判断以下三个叉积是否**同号**（例如，如果顶点是逆时针，则都为正）：

1. `cross_product(B-A, P-A)`
2. `cross_product(C-B, P-B)`
3. `cross_product(A-C, P-C)`

> **优点**：非常稳健，对凹凸四边形都有效，逻辑清晰。 **缺点**：需要进行两次三角形测试，计算量稍多。



10瓶水，其中一瓶有毒，而且毒性无敌，稀释一亿倍毒性都不减，毒性的发作时间最长为1小时，1小时后，你要用最少多少只老鼠找出有毒的水



## struct Test { int a; char b; short c; };内存布局

8



 如果说我随便插了一个数据类型，但不知道加的是什么成员，怎么算c，怎么取到c



## class A { public: int _a; A(int a) : _a(a) {} };  void print(const A& a) { std::cout << a._a << std::endl; }  void test1() { print(2);   }   可不可以，有没有问题

`void print(const A& a)`✅ **Yes**

`void print(A& a)`❌ **No**

`void print(A&& a)`✅ **Yes**

`void print(A a)` ✅ **Yes**



隐式转换  

构造函数中使用虚函数，输出顺序   虚函数工作原理

## 锁  有那些锁，  锁是怎么实现的

### 1. 核心锁：自旋锁 (Spinlock) 与 互斥锁 (Mutex)

这是最常用也是最基础的两种锁，它们的核心区别在于**等待锁的方式**。

#### **自旋锁 (Spinlock)**

- **工作原理**：当一个CPU尝试获取一个已经被占用的自旋锁时，它不会放弃CPU，而是在一个循环中**“自旋”**（原地忙等），不断地检查锁是否被释放。
- **核心特点**：
  - **速度极快**：如果锁的持有时间非常短，自旋等待的开销远小于线程上下文切换的开销。
  - **禁止休眠**：持有自旋锁的代码**绝对不能休眠**或放弃CPU（例如，不能调用`kmalloc`的非`GFP_ATOMIC`版本，不能进行I/O操作）。因为一旦休眠，可能导致其他CPU永远在等待一个不会被释放的锁，造成系统死锁。
  - **禁止抢占**：为了防止死锁，获取自旋锁时会自动禁止内核抢占。
  - **中断安全**：有专门的`spin_lock_irqsave`等变体，可以在获取锁的同时关闭本地CPU中断，用于保护中断处理程序与内核其他部分共享的数据。
- **适用场景**：
  - **中断上下文**中（这是唯一允许在中断上下文中使用的锁）。
  - 保护的**临界区非常小**，执行时间极短。
  - 确定持有锁期间**不会发生休眠**。

------



#### **互斥锁 (Mutex)**

- **工作原理**：当一个任务尝获取一个已经被占用的互斥锁时，它会被加入到一个等待队列中，然后**进入休眠状态**，将CPU让给其他任务。当锁被释放时，等待队列中的一个任务会被唤醒。
- **核心特点**：
  - **允许休眠**：持有互斥锁的代码可以安全地休眠。
  - **开销较大**：获取和释放锁的过程涉及到线程的上下文切换，如果锁的竞争不激烈或临界区很短，其开销会比自旋锁大。
  - **高效处理长临界区**：如果临界区执行时间较长，或者竞争非常激烈，让任务休眠远比让CPU空转要高效。
  - **禁止在中断上下文中使用**：中断处理程序不能休眠。
- **适用场景**：
  - 保护的**临界区较大**，执行时间较长。
  - 持有锁期间**可能会发生休眠**（如内存分配、I/O操作）。
  - 只能在**进程上下文**中使用。



### 2. 读写场景特化锁

#### **读写锁 (Reader-Writer Lock, rwlock)**

- **工作原理**：允许多个“读者”同时进入临界区，但只允许一个“写者”进入。当有写者时，所有读者和其他写者都必须等待。
- **核心特点**：遵循“读共享、写独占”的原则。
- **适用场景**：适用于**读多写少**的场景。如果读写操作非常频繁，其性能可能不如简单的自旋锁，因为其内部实现更复杂。它也有基于自旋锁和信号量的两种实现。

------



#### **顺序锁 (Seqlock)**

- **工作原理**：一种高度优化的读写锁，**极度偏向写者**。写者可以随时进入并更新数据，即使有读者正在读取。它通过一个序列计数器来实现。
  - **写者**：获取锁，递增序列号，写入数据，再次递增序列号。
  - **读者**：进入前读取序列号，读取数据，完成后再次读取序列号。如果两次读取的序列号一致且为偶数，则说明读取过程中没有被写者打断，数据是有效的。否则，读者需要重新读取。
- **核心特点**：读者完全不会阻塞写者，实现了极高的写入性能。
- **适用场景**：
  - **写操作非常频繁**，读操作次之。
  - 被保护的数据结构非常简单（通常是几个变量）。
  - 读者可以接受“读取失败并重试”的逻辑。例如，更新系统时间或统计数据。



### 3. "锁"的变体与高级机制

#### **信号量 (Semaphore)**

- **工作原理**：与互斥锁类似，也是一种休眠锁。但它可以允许**N个持有者**同时进入临界区，N在初始化时指定。当N=1时，它被称为**二元信号量**，行为非常像互斥锁。
- **核心特点**：可以用于控制对一组资源的并发访问。
- **适用场景**：历史上用途广泛，但现在对于纯粹的互斥保护，内核推荐使用Mutex，因为它提供了更严格的锁约束（如只能由锁持有者释放）。

------



#### **RCU (Read-Copy-Update)**

- **工作原理**：一种非常高级的、**无锁**的同步机制，专门用于**极度读多写少**的场景。
  - **读者**：访问数据时**完全不需要加锁**，也几乎没有性能开销。
  - **写者**：不能直接修改数据，而是先**复制**一份数据，在副本上进行修改，然后通过一次原子操作（如修改指针）将**更新**发布出去。旧版本的数据需要等待一个“宽限期”（Grace Period），确保所有正在引用它的读者都退出后，才能被安全地释放。
- **核心特点**：实现了读者和写者之间的“无等待”并发，读操作性能极高。
- **适用场景**：网络路由表、文件系统目录缓存等需要极高性能读取的数据结构。



网络层的意义，如何做到的

## B树 B+树  的区别  优缺点

|              | B树 (B-Tree)                                             | B+树 (B+-Tree)                                               |
| ------------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| **核心优势** | 点查询可能更快（理论上）                                 | **范围查询极快**，树高更低，查询性能稳定                     |
| **主要应用** | 一些文件系统（如HFS+, NTFS的部分元数据）和非关系型数据库 | **关系型数据库索引**（如MySQL的InnoDB, PostgreSQL），是事实上的标准 |





## redis为什么引入多线程





