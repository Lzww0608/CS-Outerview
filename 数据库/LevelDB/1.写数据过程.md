插入一条数据（Key-Value对）会触发一系列的流水线操作，核心思想是**将随机写转换成顺序写，将数据写入推迟到后台合并**。

下面我们来详细分解这个过程。



### 总结概览

当调用 `db->Put(key, value)` 时，数据并**不是**立刻写入到最终的磁盘文件里。整个过程分为两个主要阶段：

1. **前台立即执行的操作 (非常快)**：
   - 将操作写入**日志文件 (Log / WAL)**。
   - 将数据插入**内存中的数据结构 (MemTable)**。
   - 完成这两步后，`Put` 操作就返回成功了。
2. **后台异步执行的操作 (延迟发生)**：
   - 当 MemTable 写满后，会转换成**不可变的 MemTable (Immutable MemTable)**。
   - 后台线程会将 Immutable MemTable 的内容**刷盘 (Flush)**，生成一个 Level 0 层的 **SSTable 文件**。
   - 后台线程会执行**压缩 (Compaction)** 操作，将低层级的 SSTable 文件与高层级的文件合并，优化存储结构，删除无效数据。

接下来，我们逐步拆解每一步的细节。

------



### 详细步骤分解

假设我们现在要插入一条数据 `Put("user123", "data")`。

#### 阶段一：前台操作（同步，快速返回）

1. 获取写锁

   LevelDB 内部是单写入线程模型，通过一个锁来保证任意时刻只有一个写操作在进行，避免了复杂的多线程写冲突。

2. **写入日志文件 (Write-Ahead Log, WAL)**

   - **目的**：保证**持久性 (Durability)**。
   - **操作**：LevelDB 会将这次 `Put` 操作（包括key和value）作为一条记录，以**追加（Append-only）**的方式写入到一个 `.log` 文件中。
   - **为什么快**：磁盘的顺序写速度远高于随机写。追加日志是一个纯粹的顺序写操作，所以非常快。
   - **作用**：如果在数据还未完全刷到磁盘（SSTable文件）时，数据库进程崩溃或服务器断电，那么在下次启动时，LevelDB 可以通过重放（Replay）这个 `.log` 文件来恢复内存中的 MemTable，从而保证数据不丢失。

3. **写入内存数据结构 (MemTable)**

   - **目的**：提供**高速的写入和近期读取**。
   - **操作**：在日志写入成功后，这条 `("user123", "data")` 键值对会被插入到内存中的 `MemTable` 里。
   - **数据结构**：`MemTable` 的底层通常是一个**跳表 (Skip List)**。这是一个有序的数据结构，支持高效的插入、删除和查找（平均时间复杂度为 O(log n)）。
   - **为什么快**：所有操作都在内存中完成，速度极快。

4. 返回成功

   当数据成功写入 WAL 和 MemTable 后，Put 函数就会向上层应用返回，表示写入成功。注意，此时数据的主体仍然在内存中，尚未成为最终的磁盘文件（SSTable）。这正是 LevelDB 写入性能高的关键所在。

------



#### 阶段二：后台操作（异步，不阻塞写入）

前台的写入操作会不断进行，`MemTable` 的大小也在持续增长。当 `MemTable` 的大小达到一个预设的阈值时（例如，默认4MB），后台机制就会被触发。

1. **MemTable 切换为 Immutable MemTable**
   - 当当前的 `MemTable` 写满了，LevelDB 会：
     - 将这个 `MemTable` 转换为**只读**状态，我们称之为 `Immutable MemTable`（不可变 MemTable）。
     - 创建一个**全新的、空的 MemTable**，用于服务后续新的写入请求。
   - **作用**：这个切换过程非常迅速，确保了新的写请求几乎不会被阻塞，可以继续无缝地写入新的 `MemTable`。
2. **刷盘 (Minor Compaction / Flush)**
   - 此时，一个后台的**压缩线程 (Compaction Thread)** 会被唤醒。
   - 它会遍历 `Immutable MemTable` 中的所有数据（这些数据在跳表中已经是有序的了）。
   - 然后将这些有序的键值对写入到一个**新的磁盘文件**中。这个文件被称为 **SSTable (Sorted String Table)**。
   - 这个新生成的 SSTable 文件会被放在 **Level 0** 层。
   - 一旦 SSTable 文件成功写入磁盘，对应的 `Immutable MemTable` 就可以被释放，日志文件（.log）中相关的记录也变得不再必要。
3. **分层压缩 (Major Compaction)**
   - **问题**：Level 0 层的 SSTable 文件是直接由 MemTable dump 产生的，所以 Level 0 的多个文件之间可能存在**键范围重叠**。当查找一个 key 时，最坏情况需要查询 Level 0 的所有文件，影响读取性能。
   - **解决**：后台压缩线程会执行更复杂的“分层压缩”。
     - 它会从 Level N 层选择一个文件。
     - 找到这个文件在 Level N+1 层中所有键范围与之重叠的文件。
     - 将这些文件（N层的一个 + N+1层的多个）一起读入内存，进行**归并排序**。
     - 在合并过程中，**处理重复的 key**（保留版本更新的，即在高层级的）和**已标记为删除的 key**（直接丢弃）。
     - 将合并、清理后的结果写入到 Level N+1 层的若干个**新的 SSTable 文件**中。
     - 从 Level 1 开始，同一层级内的 SSTable 文件保证**键范围互不重叠**，这极大地提高了读取效率。
     - 删除掉合并前的旧文件（N层的一个和N+1层的多个）。



### 总结

所以，一次 `Put` 操作的完整生命周期是：

**用户视角**：`Put()` -> 写日志 (WAL) -> 写内存 (MemTable) -> **返回成功**

**LevelDB 内部**：

1. MemTable 空间不足。
2. 切换为 Immutable MemTable，并创建新 MemTable。
3. 后台线程将 Immutable MemTable dump 成 Level 0 的 SSTable 文件。
4. 后台线程在合适的时机，将 Level N 的文件和 Level N+1 的文件合并（Compaction），生成新的 Level N+1 文件，并删除旧文件。

这个基于 **LSM-Tree (Log-Structured Merge-Tree)** 的架构，通过将离散的随机写入转换为内存中的操作和磁盘上的批量顺序写入，巧妙地回避了磁盘随机写的性能瓶颈，从而获得了极高的写入吞吐量。