使用 GDB 调试多线程程序时，关键在于**管理和切换线程上下文**，以及**控制线程的执行**。GDB 提供了一套专门的命令来处理这些情况。

以下是在 GDB 中调试多线程程序的关键命令和步骤：



### 1. 查看线程：`info threads`

当程序停在断点处时，您首先需要知道当前有多少线程，以及它们分别处于什么状态。

代码段

```
(gdb) info threads
```

GDB 会列出所有线程，每个线程都有一个 GDB 分配的**唯一ID**。当前 GDB 正在调试的线程会用星号 `*` 标记。

**输出示例：**

```
  Id   Target Id         Frame
* 1    Thread 0x7ffff7f9d740 (LWP 1234) "my_app" 0x000055555555513a in main () at main.c:10
  2    Thread 0x7ffff779c700 (LWP 1235) "worker_thread" 0x00007ffff7bc5a9d in nanosleep () at ../sysdeps/unix/syscall-template.S:84
  3    Thread 0x7ffff6f9b700 (LWP 1236) "io_thread"   0x00007ffff7acba0b in poll () at ../sysdeps/unix/sysv/linux/poll.c:41
```

- `Id 1` 是 GDB 的线程号（我们主要使用这个）。
- `*` 号表示 `Id 1` (主线程) 是当前线程。
- `LWP 1235` 是 Linux 的轻量级进程ID（即系统线程ID）。
- `"worker_thread"` 是线程名（如果程序设置了的话）。
- 最后显示的是该线程当前的函数调用栈帧。



### 2. 切换线程：`thread <id>`

GDB 的大多数命令（如 `print`、`bt`、`step`、`next`）都只对**当前线程**生效。要查看其他线程的状态，您必须切换到它。

代码段

```
(gdb) thread 2
```

执行上述命令后，GDB 会切换到 `Id 2` 线程，并显示该线程的上下文。

```
[Switching to thread 2 (Thread 0x7ffff779c700 (LWP 1235))]
#0  0x00007ffff7bc5a9d in nanosleep () at ../sysdeps/unix/syscall-template.S:84
```

此时，您再使用 `bt` (backtrace) 查看的就是 `Id 2` 线程的调用栈了。



### 3. 查看所有线程的调用栈：`thread apply all bt`

如果您不想一个一个切换线程来查看它们在做什么，可以使用 `thread apply` 命令让所有（或指定）线程执行同一个 GDB 命令。

代码段

```
(gdb) thread apply all bt
```

这个命令会打印出**所有**线程的调用栈，这对于快速定位死锁（多个线程卡在锁上）或竞态条件（Race Condition）非常有用。



### 4. 控制线程执行：`scheduler-locking`

默认情况下，当您使用 `step` 或 `next` 单步调试一个线程时，GDB 也会让其他线程继续运行（`scheduler-locking off` 模式）。这可能会导致您正在调试的线程的状态被其他线程改变，使调试变得困难。

为了解决这个问题，您可以**锁定调度器**，让 GDB **只运行当前线程**。

代码段

```
(gdb) set scheduler-locking on
```

- `on`：只有当前线程会执行。当您 `step` 或 `next` 时，其他所有线程都会被 GDB 挂起。
- `off`：（默认值）所有线程都会执行。
- `step`：一种折中模式。在 `step` 单步时，其他线程暂停；但在 `next`, `continue`, `finish` 时，其他线程会运行。

**调试建议：** 当您怀疑某个特定线程有问题并想隔离它时，`set scheduler-locking on` 非常有用。



### 5. 线程相关的断点：`break ... thread <id>`

您可以设置一个只在特定线程命中时才触发的断点。

代码段

```
(gdb) break my_function thread 2
```

这样，`my_function` 只有在 `Id 2` 线程中被调用时，程序才会暂停。其他线程调用 `my_function` 时不会触发断点。



### 调试多线程的典型流程

1. 启动程序 `gdb ./my_app`，然后 `run`。
2. 程序在某个断点处停下，或者因为崩溃而停下。
3. 使用 `info threads` 查看所有线程的状态。
4. 如果程序停在线程A，但您怀疑问题出在线程B（例如，线程B持有一个锁导致A卡住）。
5. 使用 `thread <B_id>` 切换到线程B。
6. 使用 `bt` 查看线程B的调用栈，看它卡在哪里。
7. 使用 `print <variable>` 查看线程B的局部变量或相关全局变量。
8. **（如果需要隔离调试）** 使用 `set scheduler-locking on` 锁定当前线程B。
9. 使用 `step` 或 `next` 在线程B中单步执行，观察其行为。
10. **（如果需要全局概览）** 使用 `thread apply all bt` 查看所有线程的调用栈，分析它们之间的依赖关系。
11. 使用 `continue` 继续执行。


