

简单来说：**是的，虚函数表 (vtable) 中存放的通常是函数在进程的虚拟地址空间中的“绝对”地址。**

不过，这个“绝对”需要一点解释，它关系到程序是如何被加载到内存中的。



### 1. 为什么是“绝对”地址？

当 C++ 程序通过基类指针或引用调用一个虚函数时，它需要执行以下步骤：

1. 通过对象的 `vptr` (虚函数表指针) 找到该类对应的 vtable。
2. 在 vtable 中，根据一个固定的、编译时确定的偏移量（索引），取出对应虚函数的地址。
3. **直接跳转到（或调用）这个地址。**

第 3 步是关键。CPU 需要一个完整、可执行的地址才能跳转。它不能是一个“相对地址”（比如“vtable 地址 + 100 字节”），而必须是一个指向函数第一条指令的*完整*内存地址。

在现代操作系统中，这个地址是**虚拟地址空间 (Virtual Address Space)** 中的地址。



### 2. “绝对”地址何时确定？（重要）

你可能会想：如果我每次运行程序，操作系统都可能把它加载到内存的不同位置（由于 ASLR - 地址空间布局随机化），那这个地址怎么能是“绝对”的呢？

这就是**动态链接器 (Dynamic Linker/Loader)** 的工作。

- **编译和链接时：** 当编译器生成目标文件（.o）和可执行文件时，vtable 中的条目可能只是一个“占位符”或者一个需要*重定位 (relocation)* 的标记。
- **程序加载时：** 当你运行程序时，操作系统内核和动态链接器会将你的可执行文件以及它所依赖的共享库（.so 或 .dll）加载到内存中。在这个过程中，链接器会执行**重定位**操作。它会计算出所有函数（包括虚函数）在当前进程虚拟地址空间中的*最终*绝对地址，然后用这个地址去“填充”vtable。

**总结一下：**

1. vtable 中存储的是**函数指针**。
2. 这个指针的值是一个**绝对的虚拟地址**（例如 `0x000055f10a3b8f20`）。
3. 这个绝对地址是在**程序加载时**（而不是编译时）由动态链接器最终确定和填入的。

所以，一旦程序运行起来，vtable 中存放的就是可以直接跳转和执行的、完整的函数地址。